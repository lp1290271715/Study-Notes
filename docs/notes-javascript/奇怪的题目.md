# 奇怪的一些题目

## 问题一：

请问以下代码输出什么？

```javascript
var f = (
    function f() {
        return 1
    },
    function p() {
        return '2'
    })()
console.log(typeof f)
```

答案是：string

**知识点**：逗号在JavaScript中其实是个运算符，会将逗号前边和后边的表达式进行计算，再返回后边的表达式。如下：

```javascript
//一定要加括号，否则会报语法错误
var a = (1 - 1, 1 + 1)
console.log(a) // 2
```

## 问题二

请问一下代码输出什么？

```
var x = 1 ; 
if(function f(){ } ) {
	x += typeof f
}
console.log(x) 
```

答案是：1undefined

**知识点**：括号()会把里面的东西变成表达式，也就是function f(){}放在括号里面就不是函数声明了，f自然也就不是函数了，并且f啥都不是，是一个未定义的东西。而使用typeof对一个未定义的东西求类型并不会报错，而是会返回字符串"undefined"，因此结果是1undefined 。

## 问题三

```javascript
function Person(){
	this.name = 'zhang san'
	this.sex = 'male'
	return {}
}
var person = new Person()
console.log(person) 
```

**知识点：**当对一个函数使用new关键字的时候，会在该函数里面进行三个隐式的操作：

1. **创建this对象**

2. **给this对象赋值**

3. **返回this对象**

上述代码手动返回了一个{}，将隐式操作里的最后一步覆盖掉了，结果就只能返回{}，再new出来的对象都是{}

```javascript
function Person(){
	this.name = 'zhang san'
	this.sex = 'male'
	return 123
}
var person = new Person()
console.log(person) // { name : 'zhang san',sex: 'male'}
```

**知识点**：当对一个函数使用new关键字时，该函数只能返回引用类型，不能返回基本类型，返回的基本类型自动忽略，改为返回隐式的this对象

## 问题四

以下代码输出什么？

```javascript
var num = 123 

num.a = 'abc' //隐式操作：new Number(123).a = 'abc'   <-- delete
console.log(num.a) //隐式操作： console.log(new Number(123).a)          undefined
```

**知识点：**基本类型的数据是不能有属性和方法的，在给num增加a的时候，系统会默认执行一个操作：new Number(123).a = 'abc' ，然后销毁刚创建的num对象(delete)，当再访问num.a的时候，系统又会执行new Number(123).a，结果自然是undefined，这个过程叫做**包装类**

**趁热打铁：**

```javascript
var str = 'abcd'
str.length = 2 // 隐式操作：new String('abcd').length = 2
console.log(str) // 'abcd'
console.log(str.length) // 4  new String('abcd').length
```

## 问题5

一下代码输出什么？

```JavaScript
var x = 1, y = z = 2
function add(n) {
    return n = n + 1
}
y = add(x)
function add(n) {
    return n = n + 3
}
z = add(x)
console.log(x, y, z) // 1,4,4
```

知识点1：预编译时后面的add函数会覆盖前面的函数

知识点2：return n = n + 1 这种语句会先计算n，然后返回n

## 问题6

如下代码输出什么？

```javascript
Person.prototype.name = 'sunny'
funtion Person(){
	
}
var person = new Person(){}
Person.prototype.name = 'cherry'
console.log(person.name) // 'cherry'
Person.prototype = {
	name : 'marry'
}
console.log(person.name) //'cherry'
```

知识点：当new生成一个对象时，会在构造函数中隐式执行这个步骤：var this = {\_\_proto\_\_: Person.prototype }

此时，实例对象person.\_\_proto\_\_属性指向Person.prototype属性同一个内存地址，也就是同一个对象，当Person.prototype.name改变时，该内存地址的对象name属性相应改变，因此person.\_\_proto\_\_.name也跟着变了，但是当执行Person.prototype = { name : 'marry' }的时候了，是Person.prototype指向的内存空间变了，指向了新对象的内存空间，但是person.\_\_proto\_\_还是指向原来的内存空间，因此person.\_\_proto\_\_.name不变。

## 问题7

很多浏览器body都有默认的margin，值是多少？

答：ie下是20px，其他主流浏览器是8px



## 问题8

```javascript
var name = 222
var a = {
	name : '111',
	say: function(){
		console.log(this.name)
	}
}
var b = {
	name : 333,
	say: function(fn){
		fn() 
	}
}
b.say(a.say) // 222

```

知识点：this指向问题，当调用函数是这种形式aaa.fn()的话，this就指向aaa,如果是fn()这种形式调用，则this指向window，这道题里面虽然是b.say(a.say)，但是b.say()里面执行的并不是this.fn(),而是fn(),这样的话fn函数里面的this并不是b，也不是a，而是window

# 问题9

```javascript
var bar = { a: '123' }
function print() {
    bar.a = 'a'
    Object.prototype.b = 'b'
    return function inner() {
        console.log(bar.a) // a
        console.log(bar.b) // b
    }
}
print()()
```

知识点：bar是一个对象，其__proto\_\_指向Object.prototype，因此能顺着原型链去找b

